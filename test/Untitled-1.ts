// Generated by CodiumAI

import { BadRequestException } from '@nestjs/common';
import { Repository } from 'typeorm';
import { CompanyService } from '../src/company/company.service';
import { EmployeeService } from '../src/employee/employee.service';
import { EmployeeEntity } from '../src/employee/entity/employee.entity';
import { LoanEntity, LoanStatus } from '../src/loan/entity/loan.entity';
import { PaymentApiService } from '../src/loan/external-services/payment-api.service';
import { ScoreApiService } from '../src/loan/external-services/score-api.service';
import { LoanService } from '../src/loan/loan.service';

describe('LoanService', () => {
  // verifyIfHasScore returns true
  it('should return true when employee has a score above the minimum and salary is above the minimum', async () => {
    // Arrange
    const employeeId = 1;
    const loanService = new LoanService(
      loanRepository,
      employeeService,
      employeeScore,
      paymentStatus,
    );
    const mockScore = jest
      .spyOn(employeeScore, 'fetchData')
      .mockResolvedValue({ score: 500 });
    const mockSalary = jest
      .spyOn(employeeService, 'getEmployeeSalary')
      .mockResolvedValue(3000);

    // Act
    const result = await loanService.verifyIfHasScore(employeeId);

    // Assert
    expect(result).toBe(true);
    expect(mockScore).toHaveBeenCalled();
    expect(mockSalary).toHaveBeenCalledWith(employeeId);
  });

  // verifyIfHasScore returns false
  it('should return false when employee has a score below the minimum and salary is below the minimum', async () => {
    // Arrange
    const employeeId = 1;
    const loanService = new LoanService(
      loanRepository,
      employeeService,
      employeeScore,
      paymentStatus,
    );
    const mockScore = jest
      .spyOn(employeeScore, 'fetchData')
      .mockResolvedValue({ score: 300 });
    const mockSalary = jest
      .spyOn(employeeService, 'getEmployeeSalary')
      .mockResolvedValue(1500);

    // Act
    const result = await loanService.verifyIfHasScore(employeeId);

    // Assert
    expect(result).toBe(false);
    expect(mockScore).toHaveBeenCalled();
    expect(mockSalary).toHaveBeenCalledWith(employeeId);
  });

  // verifyAmountLimit returns an amount available greater than or equal to the requested amount
  it('should return an object with amountAvailable greater than or equal to the requested amount', async () => {
    // Arrange
    const employeeId = 1;
    const companyId = 1;
    const amount = 5000;
    const loanService = new LoanService(
      loanRepository,
      employeeService,
      employeeScore,
      paymentStatus,
    );
    const mockEmployee = { salary: 10000 };
    const mockEmployeeService = jest
      .spyOn(employeeService, 'readOne')
      .mockResolvedValue(mockEmployee);
    const mockAmountLimit = {
      amountAvailable: 10000,
      monthlyFinancingApproved: 3500,
      amountRequested: 5000,
      monthlyFinancingRequested: 83.33,
    };
    const mockVerifyAmountLimit = jest
      .spyOn(loanService, 'verifyAmountLimit')
      .mockResolvedValue(mockAmountLimit);

    // Act
    const result = await loanService.loanRequest(companyId, amount, employeeId);

    // Assert
    expect(result.amountAvailable).toBeGreaterThanOrEqual(amount);
    expect(mockEmployeeService).toHaveBeenCalledWith(employeeId);
    expect(mockVerifyAmountLimit).toHaveBeenCalledWith(employeeId, amount);
  });

  // verifyAmountLimit returns a monthly financing approved greater than or equal to the monthly financing requested
  it('should return an object with amountAvailable, monthlyFinancingApproved, amountRequested, and monthlyFinancingRequested properties', async () => {
    // Arrange
    const employeeId = 1;
    const amount = 5000;
    const loanService = new LoanService(
      loanRepository,
      employeeService,
      employeeScore,
      paymentStatus,
    );
    const mockSalary = jest
      .spyOn(employeeService, 'getEmployeeSalary')
      .mockResolvedValue(3000);

    // Act
    const result = await loanService.verifyAmountLimit(employeeId, amount);

    // Assert
    expect(result).toHaveProperty('amountAvailable');
    expect(result).toHaveProperty('monthlyFinancingApproved');
    expect(result).toHaveProperty('amountRequested');
    expect(result).toHaveProperty('monthlyFinancingRequested');
    expect(mockSalary).toHaveBeenCalledWith(employeeId);
  });

  // verifyPaymentStatus returns pending
  it('should return pending when payment status is not approved', async () => {
    // Arrange
    const loanService = new LoanService(
      loanRepository,
      employeeService,
      employeeScore,
      paymentStatus,
    );
    const mockPaymentStatus = jest
      .spyOn(paymentStatus, 'fetchData')
      .mockResolvedValue({ message: '' });

    // Act
    const result = await loanService.verifyPaymentStatus();

    // Assert
    expect(result).toBe(LoanStatus.pending);
    expect(mockPaymentStatus).toHaveBeenCalled();
  });

  // loanRequest returns a request object with statusPayment pending when paymentStatus message is false and amount requested is less than or equal to amount available
  it('should return a request object with statusPayment pending when paymentStatus message is false and amount requested is less than or equal to amount available', async () => {
    // Arrange
    const companyId = 1;
    const amount = 1000;
    const employeeId = 1;
    const loanRepository = new LoanRepository();
    const employeeService = new EmployeeService(
      employeeRepository,
      companyService,
    );
    const employeeScore = new ScoreApiService();
    const paymentStatus = new PaymentApiService();
    const loanService = new LoanService(
      loanRepository,
      employeeService,
      employeeScore,
      paymentStatus,
    );
    const mockGetEmployeeCompany = jest
      .spyOn(employeeService, 'getEmployeeCompany')
      .mockReturnValue(true);
    const mockGetPaymentStatus = jest
      .spyOn(paymentStatus, 'getPaymentStatus')
      .mockResolvedValue({ message: false });
    const mockVerifyIfHasScore = jest
      .spyOn(loanService, 'verifyIfHasScore')
      .mockReturnValue(true);
    const mockVerifyAmountLimit = jest
      .spyOn(loanService, 'verifyAmountLimit')
      .mockResolvedValue({
        amountAvailable: 2000,
        monthlyFinancingApproved: 100,
        amountRequested: 1000,
        monthlyFinancingRequested: 16.67,
      });
    const mockSaveLoanRequest = jest
      .spyOn(loanService, 'saveLoanRequest')
      .mockImplementation();

    // Act
    const result = await loanService.loanRequest(companyId, amount, employeeId);

    // Assert
    expect(result).toEqual({
      amountAvailable: 2000,
      monthlyFinancingApproved: 100,
      amountRequested: 1000,
      monthlyFinancingRequested: 16.67,
      statusPayment: LoanStatus.pending,
    });
    expect(mockGetEmployeeCompany).toHaveBeenCalledWith(employeeId, companyId);
    expect(mockGetPaymentStatus).toHaveBeenCalled();
    expect(mockVerifyIfHasScore).toHaveBeenCalledWith(employeeId);
    expect(mockVerifyAmountLimit).toHaveBeenCalledWith(employeeId, amount);
    expect(mockSaveLoanRequest).toHaveBeenCalledWith({
      employee: employeeId,
      amount: 1000,
      status: LoanStatus.pending,
    });
  });

  // loanRequest returns a request object with statusPayment approved when paymentStatus message is true and amount requested is less than or equal to amount available
  it('should return a request object with statusPayment approved when paymentStatus message is true and amount requested is less than or equal to amount available', async () => {
    // Arrange
    const companyId = 1;
    const amount = 1000;
    const employeeId = 1;
    const loanService = new LoanService(
      loanRepository,
      employeeService,
      employeeScore,
      paymentStatus,
    );
    const mockEmployee = { company: { companyId: 1 } };
    const mockEmployeeService = jest
      .spyOn(employeeService, 'readOne')
      .mockResolvedValue(mockEmployee);
    const mockPaymentStatus = jest
      .spyOn(paymentStatus, 'fetchData')
      .mockResolvedValue({ message: true });
    const mockVerifyIfHasScore = jest
      .spyOn(loanService, 'verifyIfHasScore')
      .mockResolvedValue(true);
    const mockVerifyAmountLimit = jest
      .spyOn(loanService, 'verifyAmountLimit')
      .mockResolvedValue({
        amountAvailable: 2000,
        monthlyFinancingApproved: 100,
        amountRequested: 1000,
        monthlyFinancingRequested: 20,
      });
    const mockSaveLoanRequest = jest
      .spyOn(loanService, 'saveLoanRequest')
      .mockResolvedValue();

    // Act
    const result = await loanService.loanRequest(companyId, amount, employeeId);

    // Assert
    expect(result).toEqual({
      amountAvailable: 2000,
      monthlyFinancingApproved: 100,
      amountRequested: 1000,
      monthlyFinancingRequested: 20,
      statusPayment: LoanStatus.approved,
    });
    expect(mockEmployeeService).toHaveBeenCalledWith(employeeId);
    expect(mockPaymentStatus).toHaveBeenCalled();
    expect(mockVerifyIfHasScore).toHaveBeenCalledWith(employeeId);
    expect(mockVerifyAmountLimit).toHaveBeenCalledWith(employeeId, amount);
    expect(mockSaveLoanRequest).toHaveBeenCalledWith({
      employee: employeeId,
      amount: 1000,
      status: LoanStatus.approved,
    });
  });

  // loanRequest returns a request object with statusPayment rejected when amount requested is greater than amount available
  it('should return a request object with statusPayment rejected when amount requested is greater than amount available', async () => {
    // Arrange
    const companyId = 1;
    const amount = 10000;
    const employeeId = 1;
    const loanRepository = new LoanRepository();
    const employeeService = new EmployeeService(
      employeeRepository,
      companyService,
    );
    const employeeScore = new ScoreApiService();
    const paymentStatus = new PaymentApiService();
    const loanService = new LoanService(
      loanRepository,
      employeeService,
      employeeScore,
      paymentStatus,
    );
    const mockGetEmployeeCompany = jest
      .spyOn(employeeService, 'getEmployeeCompany')
      .mockImplementation();
    const mockGetPaymentStatus = jest
      .spyOn(loanService, 'getPaymentStatus')
      .mockResolvedValue({ message: '' });
    const mockVerifyIfHasScore = jest
      .spyOn(loanService, 'verifyIfHasScore')
      .mockResolvedValue(false);
    const mockVerifyAmountLimit = jest
      .spyOn(loanService, 'verifyAmountLimit')
      .mockResolvedValue({
        amountAvailable: 5000,
        monthlyFinancingApproved: 250,
        amountRequested: 10000,
        monthlyFinancingRequested: 166.67,
      });
    const mockSaveLoanRequest = jest
      .spyOn(loanService, 'saveLoanRequest')
      .mockImplementation();

    // Act
    try {
      await loanService.loanRequest(companyId, amount, employeeId);
    } catch (error) {
      // Assert
      expect(error).toBeInstanceOf(BadRequestException);
      expect(error.message).toBe('Seu score é muito baixo no momento');
      expect(mockGetEmployeeCompany).toHaveBeenCalledWith(
        employeeId,
        companyId,
      );
      expect(mockGetPaymentStatus).toHaveBeenCalled();
      expect(mockVerifyIfHasScore).toHaveBeenCalledWith(employeeId);
      expect(mockVerifyAmountLimit).toHaveBeenCalledWith(employeeId, amount);
      expect(mockSaveLoanRequest).toHaveBeenCalledWith({
        employee: employeeId,
        amount: 10000,
        status: LoanStatus.rejected,
      });
    }
  });

  // verifyAmountLimit returns an amount available less than the requested amount
  it('should return an object with the correct amount available and requested when the requested amount is greater than the amount available', async () => {
    // Arrange
    const employeeId = 1;
    const companyId = 1;
    const amount = 100000;
    const loanService = new LoanService(
      loanRepository,
      employeeService,
      employeeScore,
      paymentStatus,
    );
    const mockEmployee = { salary: 5000 };
    const mockEmployeeService = jest
      .spyOn(employeeService, 'readOne')
      .mockResolvedValue(mockEmployee);
    const mockAmountLimit = {
      amountAvailable: 20000,
      monthlyFinancingApproved: 1000,
      amountRequested: 100000,
      monthlyFinancingRequested: 1666.67,
    };
    const mockVerifyAmountLimit = jest
      .spyOn(loanService, 'verifyAmountLimit')
      .mockResolvedValue(mockAmountLimit);

    // Act
    const result = await loanService.loanRequest(companyId, amount, employeeId);

    // Assert
    expect(result.amountAvailable).toBe(mockAmountLimit.amountAvailable);
    expect(result.amountRequested).toBe(mockAmountLimit.amountRequested);
    expect(mockEmployeeService).toHaveBeenCalledWith(employeeId);
    expect(mockVerifyAmountLimit).toHaveBeenCalledWith(employeeId, amount);
  });

  // verifyAmountLimit returns an amount available greater than the requested amount
  it('should save the loan request with status rejected when the requested amount is greater than the amount available', async () => {
    const employeeId = 1;
    const companyId = 1;
    const amount = 10000;
    const loanService = new LoanService(
      loanRepository,
      employeeService,
      employeeScore,
      paymentStatus,
    );
    const mockEmployeeService = jest.spyOn(employeeService, 'readOne').mockResolvedValue({ salary: 3000 });
    const mockVerifyAmountLimit = jest.spyOn(loanService, 'verifyAmountLimit').mockResolvedValue({ amountAvailable: 5000 });

    await loanService.loanRequest(companyId, amount, employeeId);

    expect(mockEmployeeService).toHaveBeenCalledWith(employeeId);
    expect(mockVerifyAmountLimit).toHaveBeenCalledWith(employeeId, amount);
    expect(loanRepository.insert).toHaveBeenCalledWith({
      employee: employeeId,
      amount,
      status: LoanStatus.rejected,
    });
  });

  // verifyAmountLimit returns an amount available equal to the requested amount
  it('should return an object with the correct amount available and requested when the requested amount is equal to the amount available', async () => {
    // Arrange
    const employeeId = 1;
    const companyId = 1;
    const amount = 20000;
    const loanService = new LoanService(
      loanRepository,
      employeeService,
      employeeScore,
      paymentStatus,
    );
    const mockEmployee = { salary: 5000 };
    const mockEmployeeService = jest
      .spyOn(employeeService, 'readOne')
      .mockResolvedValue(mockEmployee);
    const mockAmountLimit = {
      amountAvailable: 20000,
      monthlyFinancingApproved: 1000,
      amountRequested: 20000,
      monthlyFinancingRequested: 333.33,
    };
    const mockVerifyAmountLimit = jest
      .spyOn(loanService, 'verifyAmountLimit')
      .mockResolvedValue(mockAmountLimit);

    // Act
    const result = await loanService.loanRequest(companyId, amount, employeeId);

    // Assert
    expect(result.amountAvailable).toBe(mockAmountLimit.amountAvailable);
    expect(result.amountRequested).toBe(mockAmountLimit.amountRequested);
    expect(mockEmployeeService).toHaveBeenCalledWith(employeeId);
    expect(mockVerifyAmountLimit).toHaveBeenCalledWith(employeeId, amount);
  });

  // loanRequest saves loan request with status rejected when amount requested is greater than amount available
  it('should save loan request with status rejected when amount requested is greater than amount available', async () => {
    // Arrange
    const companyId = 1;
    const amount = 10000;
    const employeeId = 1;
    const loanRepository = new Repository<LoanEntity>();
    const employeeService = new EmployeeService(
      new Repository<EmployeeEntity>(),
      new CompanyService(),
    );
    const employeeScore = new ScoreApiService();
    const paymentStatus = new PaymentApiService();
    const loanService = new LoanService(
      loanRepository,
      employeeService,
      employeeScore,
      paymentStatus,
    );
    const mockGetEmployeeCompany = jest
      .spyOn(employeeService, 'readOne')
      .mockResolvedValue({ company: { companyId: 1 } });
    const mockGetPaymentStatus = jest
      .spyOn(paymentStatus, 'fetchData')
      .mockResolvedValue({ message: '' });
    const mockVerifyIfHasScore = jest
      .spyOn(loanService, 'verifyIfHasScore')
      .mockResolvedValue(false);
    const mockVerifyAmountLimit = jest
      .spyOn(loanService, 'verifyAmountLimit')
      .mockResolvedValue({ amountAvailable: 5000 });

    // Act
    await expect(
      loanService.loanRequest(companyId, amount, employeeId),
    ).rejects.toThrow(BadRequestException);

    // Assert
    expect(mockGetEmployeeCompany).toHaveBeenCalledWith(employeeId);
    expect(mockGetPaymentStatus).toHaveBeenCalled();
    expect(mockVerifyIfHasScore).toHaveBeenCalledWith(employeeId);
    expect(mockVerifyAmountLimit).toHaveBeenCalledWith(employeeId, amount);
  });

  // loanRequest throws BadRequestException when verifyIfHasScore returns false
  it('should throw BadRequestException when verifyIfHasScore returns false', async () => {
    // Arrange
    const companyId = 1;
    const amount = 10000;
    const employeeId = 1;
    const loanRepository = new Repository<LoanEntity>();
    const employeeService = new EmployeeService(
      new Repository<EmployeeEntity>(),
      new CompanyService(),
    );
    const employeeScore = new ScoreApiService();
    const paymentStatus = new PaymentApiService();
    const loanService = new LoanService(
      loanRepository,
      employeeService,
      employeeScore,
      paymentStatus,
    );
    const mockEmployeeCompany = jest
      .spyOn(employeeService, 'readOne')
      .mockResolvedValue({ company: { companyId: 1 } });
    const mockVerifyIfHasScore = jest
      .spyOn(loanService, 'verifyIfHasScore')
      .mockResolvedValue(false);
    const mockGetEmployeeSalary = jest
      .spyOn(loanService, 'getEmployeeSalary')
      .mockResolvedValue(3000);
    const mockSaveLoanRequest = jest.spyOn(loanService, 'saveLoanRequest');

    // Act and Assert
    await expect(
      loanService.loanRequest(companyId, amount, employeeId),
    ).rejects.toThrow(BadRequestException);
    expect(mockEmployeeCompany).toHaveBeenCalledWith(employeeId);
    expect(mockVerifyIfHasScore).toHaveBeenCalledWith(employeeId);
    expect(mockGetEmployeeSalary).toHaveBeenCalledWith(employeeId);
    expect(mockSaveLoanRequest).toHaveBeenCalledWith({
      employee: employeeId,
      amount: amount,
      status: LoanStatus.rejected,
    });
  });

  // loanRequest throws BadRequestException when getEmployeeCompany throws BadRequestException
  it('should throw BadRequestException when getEmployeeCompany throws BadRequestException', async () => {
    // Arrange
    const companyId = 1;
    const amount = 1000;
    const employeeId = 1;
    const loanService = new LoanService(
      loanRepository,
      employeeService,
      employeeScore,
      paymentStatus,
    );
    const mockGetEmployeeCompany = jest
      .spyOn(employeeService, 'getEmployeeCompany')
      .mockImplementation(() => {
        throw new BadRequestException();
      });

    // Act and Assert
    await expect(
      loanService.loanRequest(companyId, amount, employeeId),
    ).rejects.toThrow(BadRequestException);
    expect(mockGetEmployeeCompany).toHaveBeenCalledWith(employeeId, companyId);
  });

  // loanRequest saves loan request with status rejected when verifyIfHasScore returns false
  it('should save loan request with status rejected when employee has a score below the minimum', async () => {
    // Arrange
    const employeeId = 1;
    const companyId = 1;
    const amount = 10000;
    const loanRepository = new Repository<LoanEntity>();
    const employeeService = new EmployeeService(
      new Repository<EmployeeEntity>(),
      new CompanyService(),
    );
    const employeeScore = new ScoreApiService();
    const paymentStatus = new PaymentApiService();
    const loanService = new LoanService(
      loanRepository,
      employeeService,
      employeeScore,
      paymentStatus,
    );
    const mockEmployeeReadOne = jest
      .spyOn(employeeService, 'readOne')
      .mockResolvedValue({
        company: { companyId: 1 },
        salary: 5000,
      });
    const mockVerifyIfHasScore = jest
      .spyOn(loanService, 'verifyIfHasScore')
      .mockResolvedValue(false);
    const mockGetEmployeeSalary = jest
      .spyOn(loanService, 'getEmployeeSalary')
      .mockResolvedValue(5000);
    const mockGetPaymentStatus = jest
      .spyOn(loanService, 'getPaymentStatus')
      .mockResolvedValue({ message: '' });
    const mockSaveLoanRequest = jest.spyOn(loanService, 'saveLoanRequest');

    // Act
    await expect(
      loanService.loanRequest(companyId, amount, employeeId),
    ).rejects.toThrow(BadRequestException);

    // Assert
    expect(mockEmployeeReadOne).toHaveBeenCalledWith(employeeId);
    expect(mockVerifyIfHasScore).toHaveBeenCalledWith(employeeId);
    expect(mockGetEmployeeSalary).toHaveBeenCalledWith(employeeId);
    expect(mockGetPaymentStatus).toHaveBeenCalled();
    expect(mockSaveLoanRequest).toHaveBeenCalledWith({
      employee: employeeId,
      amount: amount,
      status: LoanStatus.rejected,
    });
  });

  // loanRequest saves loan request with status pending when paymentStatus message is false and amount requested is less than or equal to amount available
  it('should save loan request with status pending when paymentStatus message is false and amount requested is less than or equal to amount available', async () => {
    // Arrange
    const companyId = 1;
    const amount = 1000;
    const employeeId = 1;
    const loanRepository = new LoanRepository();
    const employeeService = new EmployeeService(
      employeeRepository,
      companyService,
    );
    const employeeScore = new ScoreApiService();
    const paymentStatus = new PaymentApiService();
    const loanService = new LoanService(
      loanRepository,
      employeeService,
      employeeScore,
      paymentStatus,
    );
    const mockEmployeeCompany = jest
      .spyOn(employeeService, 'readOne')
      .mockResolvedValue({ company: { companyId: 1 } });
    const mockPaymentStatus = jest
      .spyOn(paymentStatus, 'fetchData')
      .mockResolvedValue({ message: false });
    const mockVerifyIfHasScore = jest
      .spyOn(loanService, 'verifyIfHasScore')
      .mockResolvedValue(true);
    const mockVerifyAmountLimit = jest
      .spyOn(loanService, 'verifyAmountLimit')
      .mockResolvedValue({
        amountAvailable: 2000,
        monthlyFinancingApproved: 100,
        amountRequested: 1000,
        monthlyFinancingRequested: 16.67,
      });
    const mockSaveLoanRequest = jest
      .spyOn(loanService, 'saveLoanRequest')
      .mockImplementation();

    // Act
    const result = await loanService.loanRequest(companyId, amount, employeeId);

    // Assert
    expect(result).toEqual({
      amountAvailable: 2000,
      monthlyFinancingApproved: 100,
      amountRequested: 1000,
      monthlyFinancingRequested: 16.67,
      statusPayment: LoanStatus.pending,
    });
    expect(mockEmployeeCompany).toHaveBeenCalledWith(employeeId);
    expect(mockPaymentStatus).toHaveBeenCalled();
    expect(mockVerifyIfHasScore).toHaveBeenCalledWith(employeeId);
    expect(mockVerifyAmountLimit).toHaveBeenCalledWith(employeeId, amount);
    expect(mockSaveLoanRequest).toHaveBeenCalledWith({
      employee: employeeId,
      amount: 1000,
      status: LoanStatus.pending,
    });
  });

  // loanRequest saves loan request with status approved when paymentStatus message is true and amount requested is less than or equal to amount available
  it('should save loan request with status approved when paymentStatus message is true and amount requested is less than or equal to amount available', async () => {
    // Arrange
    const companyId = 1;
    const amount = 1000;
    const employeeId = 1;
    const loanRepository = new LoanRepository();
    const employeeService = new EmployeeService(
      employeeRepository,
      companyService,
    );
    const employeeScore = new ScoreApiService();
    const paymentStatus = new PaymentApiService();
    const loanService = new LoanService(
      loanRepository,
      employeeService,
      employeeScore,
      paymentStatus,
    );
    const mockEmployeeCompany = jest
      .spyOn(employeeService, 'readOne')
      .mockResolvedValue({ company: { companyId: 1 } });
    const mockPaymentStatus = jest
      .spyOn(paymentStatus, 'fetchData')
      .mockResolvedValue({ message: true });
    const mockEmployeeSalary = jest
      .spyOn(employeeService, 'getEmployeeSalary')
      .mockResolvedValue(2000);
    const mockVerifyAmountLimit = jest
      .spyOn(loanService, 'verifyAmountLimit')
      .mockResolvedValue({
        amountAvailable: 2000,
        monthlyFinancingApproved: 700,
        amountRequested: 1000,
        monthlyFinancingRequested: 16.67,
      });
    const mockSaveLoanRequest = jest.spyOn(loanService, 'saveLoanRequest');

    // Act
    const result = await loanService.loanRequest(companyId, amount, employeeId);

    // Assert
    expect(result).toEqual({
      amountAvailable: 2000,
      monthlyFinancingApproved: 700,
      amountRequested: 1000,
      monthlyFinancingRequested: 16.67,
      statusPayment: LoanStatus.approved,
    });
    expect(mockEmployeeCompany).toHaveBeenCalledWith(employeeId);
    expect(mockPaymentStatus).toHaveBeenCalled();
    expect(mockEmployeeSalary).toHaveBeenCalledWith(employeeId);
    expect(mockVerifyAmountLimit).toHaveBeenCalledWith(employeeId, amount);
    expect(mockSaveLoanRequest).toHaveBeenCalledWith({
      employee: employeeId,
      amount: 1000,
      status: LoanStatus.approved,
    });
  });

  // loanRequest throws BadRequestException when getPaymentStatus throws BadRequestException
  it('should throw BadRequestException when getPaymentStatus throws BadRequestException', async () => {
    // Arrange
    const companyId = 1;
    const amount = 1000;
    const employeeId = 1;
    const loanService = new LoanService(
      loanRepository,
      employeeService,
      employeeScore,
      paymentStatus,
    );
    const mockGetEmployeeCompany = jest
      .spyOn(employeeService, 'getEmployeeCompany')
      .mockImplementation();
    const mockGetScore = jest
      .spyOn(loanService, 'getScore')
      .mockRejectedValue(new BadRequestException());
    const mockGetEmployeeSalary = jest
      .spyOn(loanService, 'getEmployeeSalary')
      .mockResolvedValue(3000);
    const mockVerifyIfHasScore = jest
      .spyOn(loanService, 'verifyIfHasScore')
      .mockResolvedValue(true);
    const mockVerifyAmountLimit = jest
      .spyOn(loanService, 'verifyAmountLimit')
      .mockResolvedValue({
        amountAvailable: 2000,
        monthlyFinancingApproved: 100,
        amountRequested: 1000,
        monthlyFinancingRequested: 20,
      });
    const mockGetPaymentStatus = jest
      .spyOn(loanService, 'getPaymentStatus')
      .mockRejectedValue(new BadRequestException());
    const mockSaveLoanRequest = jest
      .spyOn(loanService, 'saveLoanRequest')
      .mockImplementation();

    // Act and Assert
    await expect(
      loanService.loanRequest(companyId, amount, employeeId),
    ).rejects.toThrow(BadRequestException);
    expect(mockGetEmployeeCompany).toHaveBeenCalledWith(employeeId, companyId);
    expect(mockGetScore).toHaveBeenCalled();
    expect(mockGetEmployeeSalary).toHaveBeenCalledWith(employeeId);
    expect(mockVerifyIfHasScore).toHaveBeenCalledWith(employeeId);
    expect(mockVerifyAmountLimit).toHaveBeenCalledWith(employeeId, amount);
    expect(mockGetPaymentStatus).toHaveBeenCalled();
    expect(mockSaveLoanRequest).not.toHaveBeenCalled();
  });
});
